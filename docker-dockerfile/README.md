# Dockerfile:

- Docker can build images automatically by reading the instructions from a Dockerfile.
- A Dockerfile must begin with a **FROM** instruction. The **FROM** instruction specifies the **Parent Image** from which you are building.
- The image is usually built by executing **Docker instructions**, which added **layers** on top of existing image.
- The final docker image can be considered as a layered structure where there is a core or a base image and on top of that, there are several layered intermediate images.

#### Let's start with the uses of the commands **RUN**, **CMD** and **ENTRYPOINT** in Dockerfile:

- All RUN, CMD and ENTRYPOINT commands have 2 forms (Shall & Executable):
- **Shell Form:** \<Instruction> \<command>
- **Executable Form:** <instruction>["executable","param1","param2",...]

## RUN:

RUN commands always executes in a new layer and creates a new image layer. It is often used for installing software packages and applications.
#### Shell Form:
```bash
<instruction> <command>
RUN apt-get -y update
```
#### Exectuable Form:
```bash
<instruction> ["executable","param1","param2",...]
RUN ["apt-get", "install", "apache2"]
```
#### Dockerfile:
```bash    
FROM ubuntu
RUN apt-get -y update && apt-get install apache2
```
```bash
FROM alpine
RUN apk add --froce httpd
```
## CMD:

CMD commands allows to set default command and/or parameter. This will be executed if you run a particular container without specifying some command, which can be overwritten from command line when docker container runs. 

#### Shell Form:
```bash
CMD command param1 param2
CMD echo "Hello World"
```
#### Exectuable Form:
```bash
CMD ["executable","param1","param2",...]
CMD ["/bin/echo", "Hello World"]
```
#### Dockerfile:
```bash
FROM alpine
CMD echo "Hello World"
```
```bash
docker run it image will print Hello World
docker run -it image /bin/bash or sh CMD is ignored and bash/shell interpreter run instead
```
## ENTRYPOINT

ENTRYPOINT command is similar to CMD, however it configures a container that will run as an executable form.  If you want to run a container with the condition that a particular command is always executed, use ENTRYPOINT.

#### Shell Form:
```bash
ENTRYPOINT command param1 param2
ENTRYPOINT echo "Hello World"
```
#### Executable Form:
```bash
ENTRYPOINT ["executable","param1","param2",...]
ENTRYPOINT ["/bin/echo", "Hello World"]
```
> Executable form of ENTRYPOINT allows you to set commands and parameters and then use either form of CMD to set addtional parameters that are more likely to be changed

#### Dockerfile:
```bash
FROM alpine
ENTRYPOINT ["/bin/echo", "Hello"]
CMD ["World"]
```

#### Dockerfile:
```bash
FROM alpine
RUN apk add python
CMD ["8.8.8.8"]
ENTRYPOINT [ "ping", "-t", "5" ] 
```

## COPY & ADD Directives:

When creating Dockerfiles, it’s often necessary to transfer files from the host system into the Docker image. These could be property files, native libraries, or other static content that our applications will require at runtime.

The Dockerfile specification provides two ways to copy files from the source system into an image: the **COPY** and **ADD** directives.
Here we will look at the difference between them and when it makes sense to use each one of them.

#### **COPY Directive:**
COPY takes in a source and destination. It only lets you copy in a local or directory from your host (the machine-building the Docker image) into the Docker image itself.
```bash
COPY <source> <destination>
```
We can specify multiple source paths and we need to use a relative path while specifying multiple sources. We can use wildcards to specify the source as well. We can specify the destination as an absolute path or relative to the WORKDIR directive if the WORKDIR directive is defined in the Dockerfile. We can change the ownership of the files or directories while copying it to the container filesystem.

#### Dockerfile - Sample
```bash
FROM httpd:2.4
COPY . /usr/local/apache2/htdocs/
```

#### **ADD Directive:**

**ADD**  does the same as **CMD** but in addition, it also supports 2 other sources. 

- A URL instead of a local file/directory.
- Auto extract tar from the source directory into the destination.

```bash
ADD <source> <destination>
```
> A valid use case for ADD is when we want to extract a local tar file into a specific directory in your Docker image.

#### Dockerfile - Sample
```bash
FROM httpd:2.4
ADD website.tar.gz /usr/local/apache2/htdocs/
```

#### When to use **ADD** or **COPY**: 
> According to the Dockerfile best practices guide, we should always prefer COPY over ADD unless we specifically need one of the two additional features of ADD. As noted above, using ADD command automatically expands tar files and specific compressed formats, which can lead to unexpected files being written to the file system in our images.

### **VOLUME:**
Volumes are the preferred mechanism for persisting data generated by and used by Docker containers. While bind mounts are dependent on the directory structure and OS of the host machine, volumes are completely managed by Docker. Volumes have several advantages over bind mounts:

- Volumes are easier to back up or migrate than bind mounts.
- You can manage volumes using Docker CLI commands or the Docker API.
- Volumes work on both Linux and Windows containers.
- Volumes can be more safely shared among multiple containers.
- Volume drivers let you store volumes on remote hosts or cloud providers, to encrypt the contents of volumes, or to add other functionality.
- New volumes can have their content pre-populated by a container.
- Volumes on Docker Desktop have much higher performance than bind mounts from Mac and Windows hosts.

> In addition, volumes are often a better choice than persisting data in a container’s writable layer, because a volume does not increase the size of the containers using it, and the volume’s contents exist outside the lifecycle of a given container.

```bash
docker volume create my-vol
```
```bash
docker volume create ls
```
```bash
docker run -d --name test -v my-vol:/app nginx:latest
```
```bash
docker inspect test
```
```bash
docker run -d --name test -v <Source Path>:<Destination Path> nginx:latest
```
example:
```bash
docker run -d --name test -v D:\data:/app nginx:latest
```
```bash
Type in the Windows file explorer: \\wsl$\docker-desktop-data\data\docker\volumes
```
### **RUN:**
The **docker run** command is used to run or start a command in a new container which means it creates a writeable layer on top of the mentioned image in the command. That’s why we call a container is a writeable image. This is the first command that we run when start learning Docker. There are a lot of options available with this command to configure the container as per our requirement like running a container in detached mode or interactive mode, specifying a name to the container, attaching network, volume, etc., exposing port to access the containers’ application externally, and many more things.

> ### How run Command Works in Docker?
When we run the **docker run** command on the terminal, Docker daemon searches for the mentioned Docker image locally and if it finds the image locally then it creates a writeable layer over the specified Docker image and starts the container using specified command and if it does not find the image locally then it firsts pull that image from the registry and by default, it goes to **hub.docker.com** if there is no local registry mentioned in the daemon.json file.
```bash
docker run -d -e "USER=test1" --name web-nginx nginx
```
### **CMD:**
Docker CMD defines the default executable of a Docker image. You can run this image as the base of a container without adding command-line arguments. In that case, the container runs the process specified by the CMD command.

The CMD instruction is only utilized if there is no argument added to the run command when starting a container. Therefore, if you add an argument to the command, you override the CMD.

### Dockerfile - Sample
```bash
FROM nginx:latest

CMD echo "Hello world!"
```

### **ENTRYPOINT:**

Docker ENTRYPOINT is a Dockerfile directive or instruction that is used to specify the executable which should run when a container is started from a Docker image. It has two forms, the first one is the **exec** form and the second one is the **shell** form. If there is no entrypoint or CMD specified in the Docker image, it starts and exits at the same time that means container stops automatically so, we must have to specify entrypoint or CMD so that when we will start the container it should execute something rather than going to stop.

### Dockerfile - Sample
```bash
FROM alpine
RUN apk add python
CMD ["8.8.8.8"]
ENTRYPOINT [ "ping", "-t", "5" ] 
```

## Docker Document Reference:
- [Docker Volumes](https://docs.docker.com/storage/)
- [Dockerfile Reference](https://docs.docker.com/engine/reference/builder/)

---

### [<<Back](https://github.com/ihorizonsr/docker-basics/tree/main/docker-container) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[Next>>](https://github.com/ihorizonsr/docker-basics/tree/main/docker-registry)
